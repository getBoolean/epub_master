@startuml PrototypeDesignClassDiagram
'skinparam linetype ortho
'skinparam backgroundColor transparent
'skinparam handwritten true
'skinparam monochrome true
'left to right direction
skinparam sequenceMessageAlign direction
hide empty members
hide empty description
'skinparam classAttributeIconSize 0
'skinparam style strictuml
'skinparam groupInheritance 4

class Client

'Convert Epub to abstract
abstract Epub <<Abstract Factory>> {
    +schema: EpubSchema
    +<<Create>> fromAdapter(adapter: EpubAdapter)
    +<<Create>> fromBytes(bytes: List<int>)
    +<<Create>> fromFile(file: File)
    +<<Create>> fromExtracted(directory: Directory)
    +{abstract} {method} title: String?
    +{abstract} {method} description: String?
    +{abstract} {method} authors: List<EpubAuthor>
    +{abstract} {method} coverImage: Future<img.Image?>
    +{abstract} {method} readingOrder: EpubReadingOrder?
    +{abstract} {method} tableOfContents: EpubTableOfContents?
    +{abstract} {method} images: Map<EpubPath, EpubImageFile>
    +{abstract} {method} cssFiles: Map<EpubPath, EpubCssFile>
}

class Epub2 extends Epub {
    +schema: EpubSchema
    +<<Create>> fromSchema(schema: EpubSchema,\n\tadapter: EpubAdapter)
    +{method} title: String?
    +{method} description: String?
    +{method} authors: List<EpubAuthor>
    +{method} coverImage: Future<img.Image?>
    +{method} readingOrder: EpubReadingOrder?
    +{method} tableOfContents: EpubTableOfContents?
    +{method} images: Map<EpubPath, EpubImageFile>
    +{method} cssFiles: Map<EpubPath, EpubCssFile>
}

class Epub3 extends Epub {
    +schema: EpubSchema
    +<<Create>> fromSchema(schema: EpubSchema,\n\tadapter: EpubAdapter)
    +{method} title: String?
    +{method} description: String?
    +{method} authors: List<EpubAuthor>
    +{method} coverImage: Future<img.Image?>
    +{method} readingOrder: EpubReadingOrder?
    +{method} tableOfContents: EpubTableOfContents?
    +{method} images: Map<EpubPath, EpubImageFile>
    +{method} cssFiles: Map<EpubPath, EpubCssFile>
}

enum EpubPathType {
    +{static} {field} container
    +{static} {field} package
    +{static} {field} html
    +{static} {field} image
    +{static} {field} css
    +{static} {field} font
    +{static} {field} audio
    +{static} {field} video
    +{static} {field} unknown
}

class EpubPath {
    +adapter: EpubAdapter
    +path: String
    +<<Create>> EpubPath(path: String,\n\tadapter: EpubAdapter)
    +{method} type: EpubPathType
    +withSeparator(pathSeparator: String): EpubPath
    +asBytes(): Future<List<int>>
}
EpubPath --o EpubPathType
Epub ..> EpubPath

Client --> Epub

'DATA ACCESS ADAPTER

abstract EpubAdapter <<Adapter>> {
    +{abstract} getFileAsBytes(path: String): Future<List<int>>
    +{abstract} {method} filePaths: Future<List<String>>
}
EpubPath --o EpubAdapter : adapts

package "package:archive" as archive {
    namespace archive.archive {
        class Archive
    }

    namespace archive.archive_io {
        class Archive
    }
}

class EpubArchiveAdapter extends EpubAdapter {
    -_archive: Archive // adaptee
    +getFileAsBytes(path: String): Future<List<int>>
    +{method} filePaths: Future<List<String>>
}
EpubArchiveAdapter --> archive.archive.Archive
class EpubArchiveIOAdapter extends EpubAdapter {
    -_archive: Archive // adaptee
    +getFileAsBytes(path: String): Future<List<int>>
    +{method} filePaths: Future<List<String>>
}
EpubArchiveIOAdapter --> archive.archive_io.Archive

class EpubExtractedIOAdapter extends EpubAdapter {
    -_rootDirectory: io.Directory // adaptee
    +getFileAsBytes(path: String): Future<List<int>>
    +{method} filePaths: Future<List<String>>
}
EpubExtractedIOAdapter --> "dart:io.Directory"

'EPUB SCHEMA

class EpubSchema {
    -_adapter: EpubAdapter
    -_rawFilePaths: Future<List<String>>
    +container: EpubContainer?
    +package: EpubPackage?
    +navigation: EpubNavigationDocument?
    +ncx: EpubNcx?
    +<<Create>> fromAdapter(adapter: EpubAdapter)
}
EpubSchema --o EpubAdapter
class EpubNavigationDocument
class EpubNcx
EpubSchema --o EpubNavigationDocument
EpubSchema --o EpubNcx

Epub --o EpubSchema
Epub ..> EpubSchema : <<creates>>

class EpubContainer {
    +{static} elementName: String
    +{static} namespace: String
    -_element: XmlElement
    +<<Create>> fromXmlElement(element: XmlElement)
    +<<Create>> fromBytes(bytes: List<int>)
    +{static} {method} path: String
    +{method} containerVersion: String?
    +{method} rootfileList: RootfileList?
    +{method} rootfile: Rootfile?
    +toXmlString(): String
}
EpubSchema --o EpubContainer

class RootfileList {
    +{static} elementName: String
    -_element: XmlElement
    +<<Create>> fromElement(element: XmlElement)
    +{method} items: List<Rootfile>
    +toXmlString(): String
}
EpubContainer --o RootfileList

class Rootfile {
    +{static} elementName: String
    -_element: XmlElement
    +<<Create>> fromElement(element: XmlElement)
    +{method} fullPath: String?
    +{method} mediaType: String?
    +toXmlString(): String
}
RootfileList "1" --o "*" Rootfile

class "EpubPackage" as EpubPackage {
    +{static} mimeType: String
    +{static} elementName: String
    +{static} namespace: String
    -_element: XmlElement
    +<<Create>> fromXmlElement(element: XmlElement)
    +<<Create>> fromBytes(bytes: List<int>)
    +{method} epubVersion: String?
    +{method} uniqueIdentifier: String?
    +{method} publicationMetadata: EpubPublicationMetadata?
    +{method} manifest: EpubManifest?
    +{method} spine: EpubSpine?
    +{method} guide: EpubGuide?
    +{method} tours: EpubTours?
    +toXmlString(): String
}
EpubSchema --o EpubPackage

@enduml