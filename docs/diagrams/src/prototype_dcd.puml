@startuml PrototypeDesignClassDiagram
'skinparam linetype ortho
'skinparam backgroundColor transparent
'skinparam handwritten true
'skinparam monochrome true
'left to right direction
skinparam sequenceMessageAlign direction
hide empty members
hide empty description
'skinparam classAttributeIconSize 0
'skinparam style strictuml
skinparam groupInheritance 4

class Client

'Convert Epub to abstract
abstract Epub <<Abstract Factory>> {
    +schema: EpubSchema
    +adapter: EpubAdapter
    +<<Create>> fromAdapter(adapter: EpubAdapter)
    +<<Create>> fromBytes(bytes: List<int>)
    +<<Create>> fromFile(file: File)
    +<<Create>> fromExtracted(directory: Directory)
    +{abstract} {method} title: String?
    +{abstract} {method} description: String?
    +{abstract} {method} authors: List<EpubAuthor>
    +{abstract} {method} coverImage: Future<img.Image?>
    +{abstract} {method} readingOrder: EpubReadingOrder?
    +{abstract} {method} tableOfContents: EpubTableOfContents?
    +{abstract} {method} images: Map<EpubPath, EpubImageFile>
    +{abstract} {method} cssFiles: Map<EpubPath, EpubCssFile>
}

class Epub2 extends Epub {
    +schema: EpubSchema
    +adapter: EpubAdapter
    +<<Create>> fromSchema(schema: EpubSchema,\n\tadapter: EpubAdapter)
    +{method} title: String?
    +{method} description: String?
    +{method} authors: List<EpubAuthor>
    +{method} coverImage: Future<img.Image?>
    +{method} readingOrder: EpubReadingOrder?
    +{method} tableOfContents: EpubTableOfContents?
    +{method} images: Map<EpubPath, EpubImageFile>
    +{method} cssFiles: Map<EpubPath, EpubCssFile>
}

class Epub3 extends Epub {
    +schema: EpubSchema
    +adapter: EpubAdapter
    +<<Create>> fromSchema(schema: EpubSchema,\n\tadapter: EpubAdapter)
    +{method} title: String?
    +{method} description: String?
    +{method} authors: List<EpubAuthor>
    +{method} coverImage: Future<img.Image?>
    +{method} readingOrder: EpubReadingOrder?
    +{method} tableOfContents: EpubTableOfContents?
    +{method} images: Map<EpubPath, EpubImageFile>
    +{method} cssFiles: Map<EpubPath, EpubCssFile>
}

Client --> Epub

'PARSER ADAPTER

abstract EpubAdapter <<Adapter>> {
    -_filePaths: Future<List<String>>
    +{abstract} getFileAsBytes(path: EpubPath): Future<List<int>>
    +{abstract} getFilePaths(): Future<List<EpubPath>>
    +getEpubSchema(): Future<EpubSchema?>
    +pathSeparatorOverrider(): String
    -_parseEpubDetails(): Future<EpubSchema?>
    +isContainerFilePath(path: EpubPath): bool
    +clear()
}

note right of EpubAdapter
    Note: It is not recommended to
    use this to serve Epubs over
    the network. It is intended
    for local file access only.
    Instead, download the entire
    Epub and use Epub.fromBytes

    Three to four consecutive
    calls are made to the
    abstract methods, which
    would result in a significant
    amount of loading time.
end note

package "package:archive" as archive {
    namespace archive.archive {
        class Archive
    }

    namespace archive.archive_io {
        class Archive
    }
}

class EpubParserArchiveAdapter extends EpubAdapter {
    -_archive: Archive // adaptee
    +getFileAsBytes(path: EpubPath): Future<List<int>>
    +getFilePaths(): Future<List<EpubPath>>
}
EpubParserArchiveAdapter --> archive.archive.Archive
class EpubParserArchiveIOAdapter extends EpubAdapter {
    -_archive: Archive // adaptee
    +getFileAsBytes(path: EpubPath): Future<List<int>>
    +getFilePaths(): Future<List<EpubPath>>
}
EpubParserArchiveIOAdapter --> archive.archive_io.Archive

class EpubParserExtractedIOAdapter extends EpubAdapter {
    -_rootDirectory: io.Directory // adaptee
    +getFileAsBytes(path: EpubPath): Future<List<int>>
    +getFilePaths(): Future<List<EpubPath>>
}
EpubParserExtractedIOAdapter --> "dart:io.Directory"

'PARSER

class EpubParser {
    -_adapter: EpubAdapter
    +readSchema(): Future<EpubSchema>
}
Epub --o EpubParser
EpubParser "*" --o "1" EpubAdapter : adapts
'Separate parser (Abstract Factory) for navigation based on package.epubVersion

'EPUB SCHEMA

class EpubSchema {
    +container: EpubContainer?
    +package: EpubPackage?
    +navigation: EpubNavigationDocument?
    +ncx: EpubNCX?
}
class EpubNavigationDocument
class EpubNCX
EpubSchema --o EpubNavigationDocument
EpubSchema --o EpubNCX

EpubParser ..> EpubSchema : <<create>>
Epub --o EpubSchema
Epub ..> EpubAdapter

class EpubContainer {
    +{static} elementName: String
    +{static} namespace: String
    +containerVersion: String?
    +rootfileList: RootfileList?
    +<<Create>> fromXmlElement(containerElement: XmlElement)
    +<<Create>> fromXmlString(containerString: String)
    +<<Create>> fromData(containerData: List<int>)
    +<<Create>> fromArchive(archive: Archive)
    +{static} {method} filepath: EpubPath
    +{method} rootfile: Rootfile?
    +toXmlString(): String
}
EpubSchema --o EpubContainer

class RootfileList {
    +{static} elementName: String
    +items: List<Rootfile>
    +<<Create>> fromXmlElement(rootfileListElement: XmlElement)
    +<<Create>> fromXmlString(rootfileListString: String)
    +<<Create>> fromData(rootfileListData: List<int>)
    +toXmlString(): String
}
EpubContainer --o RootfileList

class Rootfile {
    +{static} elementName: String
    +fullPath: String?
    +mediaType: String?
    +<<Create>> fromXmlElement(rootfileElement: XmlElement)
    +<<Create>> fromXmlString(rootfileString: String)
    +<<Create>> fromData(rootfileData: List<int>)
    +toXmlString(): String
}
RootfileList "1" --o "*" Rootfile

class EpubPackage {
    +{static} kPackageFileMimeType: String
    +{static} elementName: String
    +{static} namespace: String
    -_parser: EpubPackageParser
    +epubVersion: String?
    +uniqueIdentifier: String?
    +publicationMetadata: EpubPublicationMetadata?
    +manifest: EpubManifest?
    +spine: EpubSpine?
    +guide: EpubGuide?
    +tours: EpubTours?
    +<<Create>> fromXmlElement(containerElement: XmlElement)
    +<<Create>> fromXmlString(containerString: String)
    +<<Create>> fromData(containerData: List<int>)
    +<<Create>> fromArchive(archive: Archive)
    +{method} navigationFilePath: String?
    +toXmlString(): String
}
EpubSchema --o EpubPackage
note top of EpubPackage : combined with EpubPackageReader

class EpubData {
    +data: List<int>
    +<<Create>> fromBytes(bytes: List<int>)
    +toXmlDocument(): XmlDocument
}

class XmlDocument <<Extension>> {
    +findPackageElement(): XmlElement?
}
EpubData ..> XmlDocument : <<create>>


class EpubPackageParser {
    -_element: XmlElement
    +readVersion(): String?
    +readUniqueIdentifier(): String?
    +readPublicationMetadata(): EpubPublicationMetadata?
    +readManifest(): EpubManifest?
    +readSpine(): EpubSpine?
    +readGuide(): EpubGuide?
    +readTours(): EpubTours?
    +<<Create>> fromXmlElement(packageElement: XmlElement)
    +<<Create>> fromXmlString(packageString: String)
    +<<Create>> fromData(packageData: List<int>)
}
note right of EpubPackageParser : formerly EpubPackageReaderController
EpubPackageParser --> EpubData
EpubPackageParser --> XmlDocument
EpubPackage --o EpubPackageParser : parser

@enduml