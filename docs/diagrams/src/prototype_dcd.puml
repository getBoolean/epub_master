@startuml PrototypeDesignClassDiagram
'skinparam linetype ortho
'skinparam backgroundColor transparent
'skinparam handwritten true
'skinparam monochrome true
'left to right direction
skinparam sequenceMessageAlign direction
hide empty members
hide empty description
'skinparam classAttributeIconSize 0
'skinparam style strictuml
'skinparam groupInheritance 4

class Client

'Convert Epub to abstract
abstract Epub <<Abstract Factory>> {
    +schema: EpubSchema
    +<<Create>> fromAdapter(adapter: EpubAdapter)
    +<<Create>> fromBytes(bytes: List<int>)
    +<<Create>> fromFile(file: File)
    +<<Create>> fromExtracted(directory: Directory)
    +{abstract} {method} title: String?
    +{abstract} {method} description: String?
    +{abstract} {method} authors: List<EpubAuthor>
    +{abstract} {method} coverImage: Future<img.Image?>
    +{abstract} {method} readingOrder: EpubReadingOrder?
    +{abstract} {method} tableOfContents: EpubTableOfContents?
    +{abstract} {method} images: Map<EpubPath, EpubImageFile>
    +{abstract} {method} cssFiles: Map<EpubPath, EpubCssFile>
}

class Epub2 extends Epub {
    +schema: EpubSchema
    +<<Create>> fromSchema(schema: EpubSchema,\n\tadapter: EpubAdapter)
    +{method} title: String?
    +{method} description: String?
    +{method} authors: List<EpubAuthor>
    +{method} coverImage: Future<img.Image?>
    +{method} readingOrder: EpubReadingOrder?
    +{method} tableOfContents: EpubTableOfContents?
    +{method} images: Map<EpubPath, EpubImageFile>
    +{method} cssFiles: Map<EpubPath, EpubCssFile>
}

class Epub3 extends Epub {
    +schema: EpubSchema
    +<<Create>> fromSchema(schema: EpubSchema,\n\tadapter: EpubAdapter)
    +{method} title: String?
    +{method} description: String?
    +{method} authors: List<EpubAuthor>
    +{method} coverImage: Future<img.Image?>
    +{method} readingOrder: EpubReadingOrder?
    +{method} tableOfContents: EpubTableOfContents?
    +{method} images: Map<EpubPath, EpubImageFile>
    +{method} cssFiles: Map<EpubPath, EpubCssFile>
}

enum EpubPathType {
    +{static} {field} container
    +{static} {field} package
    +{static} {field} html
    +{static} {field} image
    +{static} {field} css
    +{static} {field} font
    +{static} {field} audio
    +{static} {field} video
    +{static} {field} unknown
}

class EpubPath {
    -_adapter: EpubAdapter
    +path: String
    <<Create>> EpubPath(path: String,\n\tadapter: EpubAdapter)
    {method} type: EpubPathType
    withSeparator(pathSeparator: String): EpubPath
    asBytes(): Future<List<int>>
}
EpubPath --o EpubPathType
Epub ..> EpubPath

Client --> Epub

'DATA ACCESS ADAPTER

abstract EpubAdapter <<Adapter>> {
    -_filePaths: List<String>
    +{abstract} getFileAsBytes(path: String): Future<List<int>>
    +{abstract} {method} filePaths: Future<List<String>>
}
EpubPath --o EpubAdapter : adapts

package "package:archive" as archive {
    namespace archive.archive {
        class Archive
    }

    namespace archive.archive_io {
        class Archive
    }
}

class EpubArchiveAdapter extends EpubAdapter {
    -_archive: Archive // adaptee
    +getFileAsBytes(path: String): Future<List<int>>
    +{method} filePaths: Future<List<String>>
}
EpubArchiveAdapter --> archive.archive.Archive
class EpubArchiveIOAdapter extends EpubAdapter {
    -_archive: Archive // adaptee
    +getFileAsBytes(path: String): Future<List<int>>
    +{method} filePaths: Future<List<String>>
}
EpubArchiveIOAdapter --> archive.archive_io.Archive

class EpubExtractedIOAdapter extends EpubAdapter {
    -_rootDirectory: io.Directory // adaptee
    +getFileAsBytes(path: String): Future<List<int>>
    +{method} filePaths: Future<List<String>>
}
EpubExtractedIOAdapter --> "dart:io.Directory"

'EPUB SCHEMA

class EpubSchema {
    -_adapter: EpubAdapter
    +container: EpubContainer?
    +package: EpubPackage?
    +navigation: EpubNavigationDocument?
    +ncx: EpubNcx?
    <<Create>> EpubSchema(adapter: EpubAdapter)
}
EpubSchema --o EpubAdapter
class EpubNavigationDocument
class EpubNcx
EpubSchema --o EpubNavigationDocument
EpubSchema --o EpubNcx

Epub --o EpubSchema
Epub ..> EpubSchema : <<creates>>

class EpubContainer {
    +{static} elementName: String
    +{static} namespace: String
    +containerVersion: String?
    +rootfileList: RootfileList?
    +<<Create>> fromAdapter(adapter: EpubAdapter)
    -<<Create>> _(containerVersion: String?,\n\trootfileList: RootfileList?)
    -<<Create>> _fromXmlElement(containerElement: XmlElement)
    -<<Create>> _fromXmlString(containerString: String)
    -<<Create>> _fromData(containerData: List<int>)
    +{static} {method} path: String
    +{method} rootfile: Rootfile?
    +toXmlString(): String
}
EpubSchema --o EpubContainer

class RootfileList {
    +{static} elementName: String
    +items: List<Rootfile>
    +<<Create>> fromElement(\n\telement: XmlElement,\n\tadapter: EpubAdapter)
    -<<Create>> _(items: List<Rootfile>)
    +toXmlString(): String
}
EpubContainer --o RootfileList

class Rootfile {
    +{static} elementName: String
    +path: EpubPath?
    +mediaType: String?
    +<<Create>> fromElement(\n\telement: XmlElement,\n\tadapter: EpubAdapter)
    -<<Create>> _(path: EpubPath?, mediaType: String?)
    +toXmlString(): String
}
RootfileList "1" --o "*" Rootfile

class "EpubPackage (combined with EpubPackageReader)" as EpubPackage {
    +{static} mimeType: String
    +{static} elementName: String
    +{static} namespace: String
    -_parser: EpubPackageParser
    +epubVersion: String?
    +uniqueIdentifier: String?
    +publicationMetadata: EpubPublicationMetadata?
    +manifest: EpubManifest?
    +spine: EpubSpine?
    +guide: EpubGuide?
    +tours: EpubTours?
    +<<Create>> fromRootfile(rootfile: Rootfile)
    +<<Create>> fromXmlElement(containerElement: XmlElement)
    +<<Create>> fromXmlString(containerString: String)
    +<<Create>> fromData(containerData: List<int>)
    +<<Create>> fromArchive(archive: Archive)
    +toXmlString(): String
}
EpubSchema --o EpubPackage

class EpubData {
    +data: List<int>
    +<<Create>> fromBytes(bytes: List<int>)
    +toXmlDocument(): XmlDocument
}

class XmlDocument <<Extension>> {
    +findPackageElement(): XmlElement?
}
EpubData ..> XmlDocument : <<create>>


class "EpubPackageParser (EpubPackageReaderController)" as EpubPackageParser {
    -_element: XmlElement
    +readVersion(): String?
    +readUniqueIdentifier(): String?
    +readPublicationMetadata(): EpubPublicationMetadata?
    +readManifest(): EpubManifest?
    +readSpine(): EpubSpine?
    +readGuide(): EpubGuide?
    +readTours(): EpubTours?
    +<<Create>> fromXmlElement(packageElement: XmlElement)
    +<<Create>> fromXmlString(packageString: String)
    +<<Create>> fromData(packageData: List<int>)
}

EpubPackageParser --> EpubData
EpubPackageParser --> XmlDocument
EpubPackage --> EpubPackageParser

@enduml